### 一、核心运维理念

在开始具体操作之前，请牢记以下核心理念：

- **容器即应用**：将每个容器视为一个独立的、自包含的应用单元，而不是一个微型虚拟机。
    
- **不可变基础设施**：镜像一旦构建完成就不再改变。任何配置更新都应通过创建新镜像来完成，而不是进入容器内部修改。
    
- **资源限制**：始终为容器设置合理的资源（CPU、内存）限制，防止“饥饿”或资源争抢。
    
- **集中化管理**：使用专业的日志、监控和编排工具，而不是依赖单个宿主机进行手工管理。
    

---

### 二、镜像管理：构建、存储与清理

镜像管理是 Docker 运维的起点。一个健康的镜像仓库是高效部署的基础。

#### 1. 高效构建镜像

- **使用多阶段构建（Multistage Build）**：这是生产环境的黄金法则。将编译、测试等耗时步骤放在一个“构建阶段”，然后将最终的可执行文件或应用复制到一个精简的“运行时阶段”，可以极大地减小镜像体积和攻击面。
    
- **利用 `.dockerignore`**：排除不必要的文件（如 `.git`, `node_modules`, `logs`）来减小构建上下文，加快构建速度。
    
- **精简基础镜像**：优先选择官方提供的 `alpine`、`slim` 或 `distroless` 等轻量级镜像作为基础。
    

#### 2. 本地镜像管理

- **查看镜像**：`docker images` 或 `docker image ls`。
    
- **清理无用镜像**：这是最常用的维护操作之一。
    
    - `docker image prune`：清理所有悬空（dangling）镜像，即没有被任何标签引用的镜像。
        
    - `docker image prune -a`：清理所有未被任何容器使用的镜像。这是最强力的清理方式。
        

#### 3. 镜像备份与迁移

- **导出镜像**：`docker save -o myapp.tar myapp:v1.0`，将镜像打包成一个 `.tar` 文件。
    
- **导入镜像**：`docker load -i myapp.tar`，将 `.tar` 文件加载到本地。
    

---

### 三、容器生命周期管理

容器是应用的实际运行实体。有效管理它们的生命周期是保证服务稳定的关键。

#### 1. 核心命令

- `docker run`：创建并启动一个新容器。
    
- `docker start/stop/restart`：启动、停止或重启一个已存在的容器。
    
- `docker rm`：删除一个已停止的容器。
    
- `docker exec -it <容器ID> /bin/bash`：进入一个正在运行的容器，进行调试或管理。
    
- `docker logs -f <容器ID>`：实时查看容器日志。
    

#### 2. 容器自动清理

为避免停止的容器占用过多磁盘空间，可以使用 `docker container prune` 命令。

- `docker container prune`：清理所有已停止的容器。
    

---

### 四、存储与数据持久化

容器是短暂的，但数据是持久的。正确管理存储是防止数据丢失的关键。

#### 1. 存储类型

- **数据卷（Volumes）**：首选方案。数据存储在宿主机的一个独立目录中，由 Docker 管理。其生命周期独立于容器，适合需要持久化存储的应用。
    
    - **创建**：`docker volume create my-vol`
        
    - **挂载**：`docker run -v my-vol:/data ...`
        
- **绑定挂载（Bind Mounts）**：将宿主机上的任意文件或目录直接挂载到容器中。适合配置文件、日志文件等需要频繁在宿主机和容器间同步的场景。
    
    - **挂载**：`docker run -v /host/path:/container/path ...`
        
- **清理数据卷**：`docker volume prune`，清理所有未被容器使用的数据卷。
    

---

### 五、网络配置与管理

高效的网络是容器间通信的基础。

- **默认网络（Bridge）**：默认情况下，容器连接到 `docker0` 网桥，但它们无法通过名称互相通信。
    
- **自定义网络（User-defined Bridge）**：**生产环境强烈推荐。**
    
    - **创建**：`docker network create my-net`
        
    - **运行**：`docker run --network=my-net --name db ...`
        
    - **作用**：在同一自定义网络中的容器，可以通过**容器名**（如 `db`）相互通信，实现内置的服务发现。
        

---

### 六、日志管理与监控

有效的日志和监控是快速排查问题的保障。

#### 1. 日志管理

- **日志驱动**：在 `/etc/docker/daemon.json` 中配置日志驱动和选项。
    
- **配置日志轮转**：
    
``` JSON
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m",
    "max-file": "5"
  }
}
 ```
    
 这将限制每个容器的日志文件大小，防止磁盘空间耗尽。
    
- **生产实践**：使用外部日志驱动（`syslog`、`journald`）或日志采集器（如 **Fluentd**），将所有容器的日志发送到集中的日志平台（如 ELK Stack）。
    

#### 2. 监控

- **`docker stats`**：用于快速查看单个或所有容器的实时资源使用情况。
    
- **生产实践**：部署 **Prometheus** 配合 **Grafana**，对 Docker 宿主机和容器进行全面的资源和性能监控。
    

---

### 七、安全最佳实践

容器安全是不可妥协的。

- **最小权限原则**：
    
    - 在 Dockerfile 中使用 `USER` 指令创建非 `root` 用户。
        
    - 在 `docker run` 时避免使用 `--privileged` 或 `--net=host` 等特权选项。
        
- **镜像安全**：
    
    - 只使用官方或受信赖的镜像。
        
    - 定期使用安全扫描工具（如 **Trivy**, **Clair**）扫描镜像中的已知漏洞。
        
- **宿主机安全**：
    
    - 使用 AppArmor 或 SELinux 增强容器隔离。
        
    - 定期更新 Docker Engine 和宿主机操作系统。
        

---

### 八、日常维护与自动化

- **自动化清理**：将 `docker system prune -a --volumes` 等命令加入 `cron` 任务，定期自动清理无用资源。
    
- **健康检查**：在 Dockerfile 中添加 `HEALTHCHECK` 指令，让 Docker 自动检查容器的健康状态。
    
